---
title: A Simple Racing Game
description: Create a simple driving game.
created: !!timestamp '2011-10-20 00:00:00'
tags:
    - beginner
    - tutorial
level: beginner
index: 3
---

# A Simple Racing Game

<script type="text/javascript" src="/media/js/tutorials/simple-racing/main.js"></script>
<canvas id="game-canvas" width="600" height="360"></canvas> 
<script type="text/javascript"> 
    pc.script.start();
</script>
<em>Use W to accelerate, A to steer left, and D to steer right.</em>

This tutorial will show you how to make the simple car racing game shown playable above. We'll set up a PlayCanvas Framework Application, which handles the main game loop then we'll programmatically 
create the following Entities: a player-controlled car, a chase camera that follows the car, a road environment for the background, and a directional light. 
We'll work through the code bit by bit below and you can download all the files as a complete sample.

For an overview of the PlayCanvas Framework read the Framework, Application and Entities, before starting this tutorial.

The entire source for this tutorial is available to [download id="20" format="2"].

## Setting up the Application

~~~javascript~~~
pc.script.main( function main() {
    var canvas = document.getElementById("game-canvas");

    // Create application
    var application = new pc.fw.Application(canvas, {
        keyboard: new pc.input.Keyboard(document)
    });

    var context = application.context;

    // Create Entities
    createCamera(context);
    createLight(context);
    createCar(context);
    createRoad(context);

    // Start main loop
    application.start();
});
~~~~~~~

Here is the opening setup of the game. To start with we pass our main() function into pc.script,main(). This will be executed when pc.script.start() is called from our index.html file.

In main() we start by finding the <canvas> element and then we create our Application and we provide it with the <canvas> and a pc.input.Keyboard input handler which is bound to the document. 
The keyboard handler can be attached to any DOMElement but it simplest to attach it to the base document as then it will always have focus.

Next we store the ApplicationContext and pass it into 4 functions which create the Entities that make up our game. More on those in a minute.

Finally we start the main update loop by calling application.start(). Now lets walk through each of those create functions in turn.

## Create a camera

~~~javascript~~~
function createCamera(context) {
    var entity = context.manager.create(pc.fw.Entity);

    context.components.camera.createComponent(entity, {
        fov: 60,
        nearClip: 1,
        farClip: 1000,
        activate: true
    });
    context.components.script.createComponent(entity, {
        urls: ["src/chase_camera.js"]
    });

    context.root.addChild(entity);
}
~~~~~~

context.manager is a instance of a pc.graph.GraphManager object. The GraphManager is used as a factory to create pc.graph.Node instances and classes derived from that class. In this case we create a new pc.fw.Entity. Entities form the basis for game objects, and we hang behaviours and data off them using Components. For the camera Entity we need two types of behaviour, provided by two different Components.

First we attach a Camera Component. context.components is an instance of the pc.fw.ComponentRegistry class which stores all registered Component systems. They can be accessed directly as properties of the ComponentRegistry, as in this case context.components.camera.

We initialise the Component with some data, Field of view (fov), near and far clipping distance, and tell it to activate and be added to the camera stack as soon as it is created.

Next we want to attach a script to the camera Entity. We do this by adding a Script Component and initialising it with the url of the script we want to execute. We'll describe how the scripts should be implemented in a minute.

Finally, we add the new entity into the graph by adding it as a child of the root Node. Only Entities that are in the graph hierarchy under the root Node will be updated and rendered.

## Create a light

~~~javascript~~~
function createLight(context) {
    var entity = context.manager.create(pc.fw.Entity);
    var rotation = pc.math.mat4.makeRotate(45.0, [1,0,0]);
    entity.setLocalTransform(rotation);

    context.components.light.createComponent(entity, {
        ambient: [0.5, 0.5, 0.5],
        diffuse: [0.8, 0.8, 0.8]
    });
    context.root.addChild(entity);
}
~~~~~~

The next Entity is set up much like the Light. In this case there we are also initialising the local transform matrix of the Entity. All Nodes in the graph have a transform matrix which you can access using getLocalTransform() and setLocalTransform(). You can also access the world transform using getWorldTransform(). The world transform is recalculated once a frame before performing the update loop.

For the Light Entity we want a Light Component, which we create and set the ambient and diffuse colors on. Finally the Entity is added into the graph.

## Create a model

~~~javascript~~~
function createCar(context) {
    var entity = context.manager.create(pc.fw.Entity);

    context.components.script.createComponent(entity, {
        urls: ["src/physics_car.js"]
    });

    var data = {
        file: {
            url: "data/ferrari/ferrari.json"
        }
    };

    var asset = context.loaders.asset.open(data);
    context.components.model.createComponent(entity, {
        asset: [asset.getGuid()]
    });

    context.root.addChild(entity);
}

function createRoad(context) {
    var entity = context.manager.create(pc.fw.Entity);

    var data = {
        file: {
            url: "data/road/road.json"
        }
    };

    var asset = context.loaders.asset.open(data);
    context.components.model.createComponent(entity, {
        asset: [asset.getGuid()]
    });

    context.root.addChild(entity);
}
~~~~~~

        
These two functions both create similar Entities to the the previous functions. They do introduce one new features though, loading Assets. context.loaders.assetpc.fw.AssetLoader class. 
This is used to download Assets ( e.g. Models, Animations, Images, etc) and open them.

Usually the Asset data would be loaded from the PlayCanvas server but in this case we create a skeleton Asset data object just containing the url of the Model File we want to open. 
Then we open it manually using context.loaders.asset.open(), this returns an Asset object which has a GUID. This GUID is used to initialise the Model Component which we attach to the Entity,

If this seems a little complicated, don't worry, The process shown here is a little lower level that you will usually have to worry about as in most cases both Entity and Asset 
data won't be hard-coded into the application code, it will be provided directly from the PlayCanvas server, or from data files loaded separately.

## Attaching scripts

So far we've shown how to create Entities and open Asset data, but how do we add code to govern the behaviour of the car and the camera?

We could implement an update function in main.js and put all our functionality into there, but then our code is tied directly into this specific game, and isn't terribly re-usable. Instead we'll use the Script Component that we hinted at when we created the Camera Entity. A Script Component can be initialised with the URLs of javascript files. These javascript files are loaded dynamically at runtime and by calling some parts of the PlayCanvas API we can create re-usable modules of behaviour attached to Entities. Best of all we can expose properties of these scripts into the PlayCanvas tools, allowing you to create your game in a powerful, designer-led, data-driven fashion.

~~~javascript~~~
pc.script.create( "chase_camera", function (context) {
    var ChaseCamera = function (entity) {
        this.entity = entity;

        // Physics coefficient which controls the influence of the camera's position
        // over the spring force. The stiffer the spring, the closer it will stay to
        // the chased object.
        this.stiffness = 8000.0;
        // Physics coefficient which approximates internal friction of the spring.
        // Sufficient damping will prevent the spring from oscillating infinitely.
        this.damping = 700.0;
        // Mass of the camera body. Heaver objects require stiffer springs with less
        // damping to move at the same rate as lighter objects.
        this.mass = 30.0;

        this.offset   = pc.math.vec3.create(0, 2, -5);
        this.position = pc.math.vec3.create(0, 0, 0);
        this.velocity = pc.math.vec3.create(0, 0, 0);
    };

    ChaseCamera.prototype.update = function (dt) {
        if(!this.target) {
            this.target = context.root.findOne("getName", "car");
            if(!this.target) {
                return;
            }
        }

        var cameraTransform = this.entity.getLocalTransform();
        var cameraPosition = pc.math.mat4.getTranslation(cameraTransform);

        // Get transform of the target entity
        var targetTransform = this.target.getLocalTransform();
        var targetPosition = pc.math.mat4.getTranslation(targetTransform);

        var offsetLocal = pc.math.mat4.multiplyVec3(this.offset, 0.0, targetTransform);
        var desiredPosition = pc.math.vec3.create();
        pc.math.vec3.add(targetPosition, offsetLocal, desiredPosition);

        var stretch = pc.math.vec3.create();
        var force = pc.math.vec3.create();
        var temp1 = pc.math.vec3.create();
        var temp2 = pc.math.vec3.create();

        // Calculate spring force
        pc.math.vec3.subtract(this.position, desiredPosition, stretch);
        pc.math.vec3.scale(stretch, -this.stiffness, temp1);
        pc.math.vec3.scale(this.velocity, this.damping, temp2);
        pc.math.vec3.subtract(temp1, temp2, force);

        // Apply acceleration
        var acceleration = temp1;
        var velocityDelta = temp2;
        pc.math.vec3.scale(force, 1 / this.mass, acceleration);
        pc.math.vec3.scale(acceleration, dt, velocityDelta);
        pc.math.vec3.add(this.velocity, velocityDelta, this.velocity);

        // Apply velocity
        var positionDelta = temp1;
        pc.math.vec3.scale(this.velocity, dt, positionDelta);
        pc.math.vec3.add(this.position, positionDelta, this.position);

        cameraTransform = pc.math.mat4.makeLookAt(this.position, targetPosition, [0,1,0]);

        this.entity.setLocalTransform(cameraTransform);
    }

    return ChaseCamera;
});
~~~~~~

        
Here is the full script for the chase camera, we won't walk through the car script in this tutorial, but the commented source code is include in the download files.

~~~javascript~~~
pc.script.create( "chase_camera", function (context) {
    var ChaseCamera = function (entity) {
        this.entity = entity;
        ...
    };

    ChaseCamera.prototype.update = function (dt) {
        ...
    };

    return ChaseCamera;
});
~~~~~~
        
Here is the script stripped down to the basic structure. We'll leave the specifics of the chase camera behaviour for you to study, as it's the structure of the script file that's important.

We start of calling the pc.script.create() function, as this code is in the main body of the file, 
this will be called the moment the script is downloaded by the engine. We pass the create() function a name for the script we are creating, 
and a function. The function is registered with the PlayCanvas script system which will be executed at a later time, once all scripts are loaded and the game is beginning. 
This function's job is to return a class which can be instanciated once for each Entity that has this script attached to it.

Looking at the code above we can see that inside the function supplied to create() a new class is defined ChaseCamera. At the end of the function this class is returned. 
So for each Entity that has this script attached, the constructor will be called with the Entity as the first argument (it's useful to store this away as a member of the instance), 
and then every frame the update() method will be called on this instance, with the frame timestep.

Hopefully you can see that we can define a nice re-usable chunk of code (in this case to make a camera follow a target) which can be attached to multiple Entities.
